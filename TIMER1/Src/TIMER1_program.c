/*
 * TIMER1_program.c
 *
 *  Created on: Sep 16, 2020
 *      Author: noureldeen albrmky
 */


#include "BIT_MATH.h"
#include "STD_TYPES.h"


#include "TIMER1_interface.h"
#include "TIMER1_private.h"
#include "TIMER1_config.h"

#define CONCBIT1(a,b,c)	CONCBIT1_HELPER(a,b,c)
#define CONCBIT1_HELPER(a,b,c) 0b##c##b##a

#define CONCBIT2(a,b,c,d,e)	CONCBIT2_HELPER(a,b,c,d,e)
#define CONCBIT2_HELPER(a,b,c,d,e) 0b##e##d##c##b##a

#define CONCBIT3(a,b,c,d,e,f,g,h)	CONCBIT3_HELPER(a,b,c,d,e,f,g,h)
#define CONCBIT3_HELPER(a,b,c,d,e,f,g,h) 0b##h##g##f##e##d##c##b##a

#define CONCBIT13(D1,D2,D3,D4,D5,D6,D7,D8,D9,D10,D11,D12,D13)	CONCBIT13_HELPER(D1,D2,D3,D4,D5,D6,D7,D8,D9,D10,D11,D12,D13)
#define CONCBIT13_HELPER(D1,D2,D3,D4,D5,D6,D7,D8,D9,D10,D11,D12,D13) 0b##D13##D12##D11##D10##D9##D8##D7##D6##D5##D4##D3##D2##D1



void MTIMER1_voidInit(void)
{

#if CAPTURE_COMPARE_1_SELECTION == CCx_OUTPUT
#define CCMR1_value CONCBIT2(CAPTURE_COMPARE_1_SELECTION,CC1_OUTPUT_FAST_ENABLE,CC1_OUTPUT_PRELOAD,CC1_OUTPUT_COMPARE_MODE,CC1_OUTPUT_CLEAR_OCxREF)
#else
#define CCMR1_value CONCBIT1(CAPTURE_COMPARE_1_SELECTION,INPUT_CAPTURE_1_PRESCALER,INPUT_CAPTURE_1_FILTER_SAMPLING)
#endif

#if CAPTURE_COMPARE_2_SELECTION == CCx_OUTPUT
#define CCMR2_value CONCBIT2(CAPTURE_COMPARE_2_SELECTION,CC2_OUTPUT_FAST_ENABLE,CC2_OUTPUT_PRELOAD,CC2_OUTPUT_COMPARE_MODE,CC2_OUTPUT_CLEAR_OCxREF)
#else
#define CCMR2_value CONCBIT1(CAPTURE_COMPARE_2_SELECTION,INPUT_CAPTURE_2_PRESCALER,INPUT_CAPTURE_2_FILTER_SAMPLING)
#endif

#if CAPTURE_COMPARE_3_SELECTION == CCx_OUTPUT
#define CCMR3_value CONCBIT2(CAPTURE_COMPARE_3_SELECTION,CC3_OUTPUT_FAST_ENABLE,CC3_OUTPUT_PRELOAD,CC3_OUTPUT_COMPARE_MODE,CC3_OUTPUT_CLEAR_OCxREF)
#else
#define CCMR3_value CONCBIT1(CAPTURE_COMPARE_3_SELECTION,INPUT_CAPTURE_3_PRESCALER,INPUT_CAPTURE_3_FILTER_SAMPLING)
#endif

#if CAPTURE_COMPARE_4_SELECTION == CCx_OUTPUT
#define CCMR4_value CONCBIT2(CAPTURE_COMPARE_4_SELECTION,CC4_OUTPUT_FAST_ENABLE,CC4_OUTPUT_PRELOAD,CC4_OUTPUT_COMPARE_MODE,CC4_OUTPUT_CLEAR_OCxREF)
#else
#define CCMR4_value CONCBIT1(CAPTURE_COMPARE_4_SELECTION,INPUT_CAPTURE_4_PRESCALER,INPUT_CAPTURE_4_FILTER_SAMPLING)
#endif

TIMER1 -> CCMR1 = (CCMR2_value<<8) + CCMR1_value;
TIMER1 -> CCMR2 = (CCMR4_value<<8) + CCMR3_value;


	/* by default is zero */
#if DEAD_TIME_SAMPLING_CLOCK == TCLK
	TIMER1 -> CR1 &= ~(0x300);
#elif DEAD_TIME_SAMPLING_CLOCK == TCLK_2
	TIMER1 -> CR1 |= 0x100;
#elif DEAD_TIME_SAMPLING_CLOCK == TCLK_4
	TIMER1 -> CR1 |= 0x200;
#else
	#error (wrong choice for DEAD_TIME_SAMPLING_CLOCK)
#endif



#if PRELOAD_ARR == ON
	SET_BIT(TIMER1 ->CR1, ARPE);
#elif PRELOAD_ARR == OFF
	CLR_BIT(TIMER1 ->CR1, ARPE);
#else
	#error (Wrong choice for PRELOAD_ARR)
#endif



#if COUNTER_MODE == EDGE_ALIGNED
	INSERT_FIELD(TIMER1 ->CR1, 0x60, 0, 5);
#elif COUNTER_MODE == CENTER_ALIGNED_MODE_1
	INSERT_FIELD(TIMER1 ->CR1, 0x60, 1, 5);
#elif COUNTER_MODE == CENTER_ALIGNED_MODE_2
	INSERT_FIELD(TIMER1 ->CR1, 0x60, 2, 5);
#elif COUNTER_MODE == CENTER_ALIGNED_MODE_3
	INSERT_FIELD(TIMER1 ->CR1, 0x60, 3, 5);
#else
	#error (Wrong choice for COUNTER_MODE)
#endif



#if ONE_PULSE_MOD == ON
	SET_BIT(TIMER1 -> CR1 , OPM);
#elif 	ONE_PULSE_MOD == OFF
	CLR_BIT(TIMER1 -> CR1 , OPM);
#else
	#error (Wrong choice for ONE_PULSE_MODE)
#endif



TIMER1 ->SMCR = CONCBIT3(	SLAVE_MODE_SELECT,0,TRIGGER_SOURCE,DELAY_TRGO_FOR_SYNCHRONIZATION,\
							EXTERNAL_TRIGGER_FILTER,EXTERNAL_TRIGGER_PRESCALER,EXTERNAL_TRIGGER_ENABLE,\
							EXTERNAL_TRIGGER_POLARITY)	;

TIMER1 ->CR2 = CONCBIT13(	PRELOAD_CONTROL					,
							0								,
							CC_CONTROL_UPDATE_SELECTION		,
							CC_DMA_SELECTION				,
							MASTER_MODE_SELECTION			,
							TRIGGER_INPUT_1_SELECTION		,
							CC1_OUTPUT_IDEAL_STATE			,
							CC1N_OUTPUT_IDEAL_STATE			,
							CC2_OUTPUT_IDEAL_STATE			,
							CC2N_OUTPUT_IDEAL_STATE			,
							CC3_OUTPUT_IDEAL_STATE			,
							CC3N_OUTPUT_IDEAL_STATE			,
							CC4_OUTPUT_IDEAL_STATE);

INSERT_BIT(TIMER1 ->BDTR,OSSI,OFF_STATE_SELECTION_FOR_IDEAL_MODE);
INSERT_BIT(TIMER1 ->BDTR,OSSR,OFF_STATE_SELECTION_FOR_RUN_MODE);
INSERT_BIT(TIMER1 ->BDTR,AOE,OFF_STATE_SELECTION_FOR_RUN_MODE);
INSERT_FIELD(TIMER1 -> BDTR,0x00FF,DEAD_TIME_GENERATOR,0);

}

void MTIMER1_voidSetCCPinsEnable_POLARITY(TIMER1_PINS_CONFIG index , TIMER1_PINS_STATES state)
{
	INSERT_BIT(TIMER1 -> CCER ,index,state);
	if( (index == MTIMER1_BREAK_ENABLE) || (index == MTIMER1_BREAK_POLARITY) )
		INSERT_BIT(TIMER1 -> BDTR ,index,state);
}

void MTIMER1_voidWriteARR(u16 Copy_u16ARRData)
{
	TIMER1 ->ARR = Copy_u16ARRData;
}

void MTIMER1_voidWriteCNT(u16 Copy_u16CNTData)
{
	TIMER1 ->CNT = Copy_u16CNTData;
}

void MTIMER1_voidWritePSC(u16 Copy_u16PSCData)
{
	TIMER1 ->PSC = Copy_u16PSCData;
}

void MTIMER1_voidWriteRCR(u16 Copy_u16RCRData)
{
	TIMER1 ->RCR = Copy_u16RCRData;
}

void MTIMER1_voidWriteCCRx(u16 Copy_u16CCRxData , u8 Copy_u8Channel)
{
	switch(Copy_u8Channel)
	{
		case TIMER1_CCR1:
			TIMER1 ->CCR1 = Copy_u16CCRxData;
			break;

		case TIMER1_CCR2:
			TIMER1 ->CCR2 = Copy_u16CCRxData;
			break;

		case TIMER1_CCR3:
			TIMER1 ->CCR3 = Copy_u16CCRxData;
			break;

		case TIMER1_CCR4:
			TIMER1 ->CCR4 = Copy_u16CCRxData;
			break;

	}
}

void MTIMER1_voidEnableMainOutput(TIMER1_STATE Copy_enumState)
{
	INSERT_BIT(TIMER1->BDTR,MOE,Copy_enumState);
}


void MTIMER1_voidEnableTimer(TIMER1_STATE Copy_enumState)
{
	INSERT_BIT(TIMER1 ->CR1, CEN ,  Copy_enumState  );
}

void MTIMER1_voidDisableUpdate(TIMER1_STATE Copy_enumState)
{
	INSERT_BIT(TIMER1 ->CR1, UDIS ,  Copy_enumState  );
}

void MTIMER1_voidUpdateRequest(TIMER1_UPDATE_REQUEST_SOURCE Copy_enumSource)
{
	INSERT_BIT(TIMER1 ->CR1, URS ,  Copy_enumSource  );
}

void MTIMER1_voidSetDirection(TIMER1_DIR Copy_enumDir)
{
	INSERT_BIT(TIMER1 ->CR1, DIR ,  Copy_enumDir  );
}


void MTIMER1_voidINTEnable(TIMER1_REQUEST_TYPE Copy_enumType , TIMER1_STATE Copy_enumState)
{
	INSERT_BIT(TIMER1 ->DIER, Copy_enumType ,  Copy_enumState  );
}

void MTIMER1_voidClearFlag(TIMER1_FLAGS Copy_u8Flag)
{
	CLR_BIT(TIMER1 ->SR,Copy_u8Flag  );
}

void MTIMER1_voidGenerateEvent(TIMER1_EVENT_GENERATION Copy_u8Event)
{
	SET_BIT(TIMER1 ->EGR,Copy_u8Event  );
}

